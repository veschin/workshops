#+title: Clojure Воркшоп 7
#+author: veschin
#+language: ru

* Многопоточность
Программная возможность выполнять действия параллельно или конкурентно.
** STM
В информатике software transactional memory (STM) - это механизм управления параллелизмом, аналогичный транзакциям базы данных, для управления доступом к общей памяти в параллельных вычислениях. Он является альтернативой синхронизации на основе блокировок.
Транзакция в данном контексте происходит, когда часть кода выполняет серию операций чтения и записи в общую память. Эти чтения и записи логически происходят в один момент времени; промежуточные состояния не видны другим (успешным) транзакциям.

** Thread
Поток рядом с основным потоком в программе
*** Пример
#+begin_src clojure
(dotimes [i 10]
  (-> (fn [] (println i))
      (Thread.)
      (.start)))
;; 09
;; 8
;; 7
;; 65
;; 3
;; 42
;; 1
#+end_src

** Future
Фьючер - асинхронное вычисление
Возвоащает ссылку
*** Дереференс
Возвращает текущее состояние по ссылке
Поддерживает такие типы данных как:
- atom
- delay
- future
- promise
- ref
- var
*** Пример
#+begin_src clojure
(future (inc 1))
;; => #<Future@3cc9163a: 2>

@(future (inc 1))
;; => 2
#+end_src

Допустим мы хотим обработать коллекцию из 100 элементов
** Параллелизм
Параллельные действия - действие разбитое на состовляющие, которые не конкурируют а выполняют какую то свою часть работы.
1. Разобьем коллекцию на чанки по 20 элементов - 5 потоков
2. Для каждого чанка сделаем поток в котором запустим вычисление
3. При успешном выполнении поток пишет данные в аккумулятор
4. Соберем данные сохраняя порядок чанков
#+begin_src clojure
(for [chunk (partition-all 20 (range 100))]
  (future (map inc chunk)))
#+end_src

** Конкурентность
Конкурентные действия - не чувствуют границы друг друга и могут пересекаться и создавать конфликтные ситуации.
1. Ограничимся 10 потоками
2. Каждый поток берет по свободному элементу и вычисляет
3. При успешном выполнении поток пишет данные в аккумулятор
4. Итоговые данные лишены порядка
#+begin_src clojure
(let [pool  (Executors/newFixedThreadPool 10)
      queue (->> (range 100)
                 (map (fn [i] #(println (inc i))))
                 (.invokeAll pool))]
  (doseq [future queue]
    (.get future))
  (.shutdown pool))
#+end_src

* Clojure - многопоточность из коробки
#+begin_src clojure
(pmap inc (range 3))
#+end_src

#+begin_src clojure
(pvalues (inc 1) (inc 2) (inc 3))
#+end_src

#+begin_src clojure
(pcalls #(inc 1) #(inc 2) #(inc 3))
#+end_src
