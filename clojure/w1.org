#+title: Clojure Воркшоп 1
#+author: veschin
#+language: ru

* Формат мероприятия
Не совсем верно называть это воркшопом,
потому что ~мы не будем программировать~ (но это не точно).

Цель мероприятия, ~познакомить с технологией~.
Показать, что это не марсианские письмена,
а такой же ~прагматичный язык программирования~ как и мейнстримные,
который должен ~решать проблемы бизнеса и помогать разработчику~.

Главная ~проблема~ обучения - ~нежелание обучаемого воспринимать информацию~.
Главная ~цель~ настоящего обучения - ~развить интерес~ к теме, и ~ответить на~ главные ~вопросы~.


* Зачем вам это нужно?
Попробуем ответить на неприятные вопросы:
** Эта технология даст вам карьерное преимущество здесь и сейчас?
Нет

** Эта технология является популярной? На ней легко найти работу?
Нет

** Зачем вообще тратить на нее свое время?
Потому что Clojure способна подарить кардинально новый опыт решения обыденных проблем.
Не нужно смотреть на этот язык, как на потенциально новый вид деятельности.
Нужно дать ему шанс, существовать в вашей карьере параллельно с основным источником дохода.


* Введение
** Lisp
Семейство языков программирования,
программы и данные в которых представляются системами линейных списков символов.
#+begin_src lisp
(car '(A B C D))
;; => A

(write-line "Hello World")
;; => nil

(* 2 3)
;; => 6
#+end_src
** Clojure
Cовременный диалект Лиспа,
язык программирования общего назначения с поддержкой разработки в интерактивном режиме,
поощряющий функциональное программирование и упрощающий поддержку многопоточности.
Clojure работает на платформах JVM и CLR.

** Синтаксис и его отсутствие
*** Функция сложения
Рассмотрим функцию сложения двух чисел.
Например в языке Java есть синтаксические правила, объявления функции.
Объявляем:
 - Тип данных, результата
 - Имя функции
 - Аргументы
 - Тело функции
#+begin_src java
int plus (x, y) {
	return x + y;
}
#+end_src

В Clojure мы делаем почти то же самое, но опускаем тип результата,
потому что язык динамически типизированный.
Через функцию* ~defn~ Объявляем:
 - Имя функции
 - Аргументы
 - Тело функции
#+begin_src clojure
(defn plus [x y] (+ x y))
#+end_src
*** Объявление переменных
Объявляем для переменной:
 - Тип
 - Имя
 - Значение
#+begin_src java
byte b = 216;
short s = 1123;
int i = 64536;
long l = 2147483648L;
float pi = 3.14f;
char a = 'a';
String a2 = "Hello";
#+end_src

Делаем в Clojure то же самое
Через функцию* ~def~
#+begin_src clojure
(def b 216)
(def s 1123)
(def i 64536)
(def l 2147483648L)
(def a \a)
(def a2 "Hello")
#+end_src
*** Условные выражения
Рассмотрим выражение,
которое в зависимости от условия выводит что-то в консоль

Выражение состоит из:
 - Условия
 - Тела условия
#+begin_src java
if(true) {
    System.out.println("True");
} else {
    System.out.println("False");
}
#+end_src

Выражение на Clojure почти полностью соответствует
#+begin_src clojure
(if true
  (println "True")
  (println "False"))

;; NOTE: или если мы хотим немного оптимизировать код
(println (if true "True" "False"))
#+end_src
*** Поговорим про синтаксис
В Clojure почти все подчиняется одному синтаксическому правилу
 - Все что исполняется,
   называется ~форма~
   и выглядит как список ~( ... )~
 - То что в ~форме~ на первом месте - ~функция~
 - Остальное ~аргументы~

Безусловно есть исключения, в виде
 - Обычных макросов
 - Структур данных
 - Ридеров
Но в контесте данного воркшопа, они нас не интересуют


* Структуры данных
** Список / List
#+begin_src clojure
(list 1 2 3 4 5 6)
;;Или
'(1 2 3 4 5 6)
;; => (1 2 3 4 5 6)
#+end_src

** Вектор / Vector
#+begin_src clojure
(vector 1 :ke H "s" [1 \n] 4 5 6)
;;Или
[1 :ke \H "s" [1 \n] 4 5 6]
#+end_src

** Строка / String
#+begin_src clojure
(def H \H)
(str H \e \l \l \o 1 2 3)
;;Или
"Hello123\n World"
#+end_src

** Кейворд / Keyword
#+begin_src clojure
(keyword "hello")
;; Или
:hello
:myns/hello
#+end_src

** Мапа / HashMap
#+begin_src clojure
(into {} :a 1 :b 2 :c 3)
;; Или
(def m
  {:a 1
   "b" 2
   1 1
   [1 2] '(1 2 3 4)})

(def r (get m :a))
;; => 1
(get m "b")
;; => 2
(get m 1)
;; => 1
(get m [1 2])
;; => (1 2 3 4)
#+end_src

** Сет / Set
#+begin_src clojure
(set [1 2 3 4 3 5 5 5])
;; Или
#{1 3 2 5 4}
#+end_src
