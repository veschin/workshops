#+title: Clojure

* Формат мероприятия
Не совсем верно называть это воркшопом,
потому что ~мы не будем программировать~ (но это не точно).

Цель мероприятия, ~познакомить с технологией~.
Показать, что это не марсианские письмена,
а такой же ~прагматичный язык программирования~ как и мейнстримные,
который должен ~решать проблемы бизнеса и помогать разработчику~.

Главная ~проблема~ обучения - ~нежелание обучаемого воспринимать информацию~.
Главная ~цель~ настоящего обучения - ~развить интерес~ к теме, и ~ответить на~ главные ~вопросы~.


* Зачем вам это нужно?
Попробуем ответить на неприятные вопросы:
** Эта технология даст вам карьерное преимущество здесь и сейчас?
Нет

** Эта технология является популярной? На ней легко найти работу?
Нет

** Зачем вообще тратить на нее свое время?
Потому что Clojure способна подарить кардинально новый опыт решения обыденных проблем.
Не нужно смотреть на этот язык, как на потенциально новый вид деятельности.
Нужно дать ему шанс, существовать в вашей карьере параллельно с основным источником дохода.


* Введение
** Lisp
Семейство языков программирования,
программы и данные в которых представляются системами линейных списков символов.
#+begin_src lisp
(car '(A B C D))
;; => A

(write-line "Hello World")
;; => nil

(* 2 3)
;; => 6
#+end_src
** Clojure
Cовременный диалект Лиспа,
язык программирования общего назначения с поддержкой разработки в интерактивном режиме,
поощряющий функциональное программирование и упрощающий поддержку многопоточности.
Clojure работает на платформах JVM и CLR.

** Синтаксис и его отсутствие
*** Функция сложения
Рассмотрим функцию сложения двух чисел.
Например в языке Java есть синтаксические правила, объявления функции.
Объявляем:
 - Тип данных, результата
 - Имя функции
 - Аргументы
 - Тело функции
#+begin_src java
int plus (x, y) {
	return x + y;
}
#+end_src

В Clojure мы делаем почти то же самое, но опускаем тип результата,
потому что язык динамически типизированный.
Через функцию* ~defn~ Объявляем:
 - Имя функции
 - Аргументы
 - Тело функции
#+begin_src clojure
(defn plus [x y] (+ x y))
#+end_src
*** Объявление переменных
Объявляем для переменной:
 - Тип
 - Имя
 - Значение
#+begin_src java
byte b = 216;
short s = 1123;
int i = 64536;
long l = 2147483648L;
float pi = 3.14f;
char a = 'a';
String a2 = "Hello";
#+end_src

Делаем в Clojure то же самое
Через функцию* ~def~
#+begin_src clojure
(def b 216)
(def s 1123)
(def i 64536)
(def l 2147483648L)
(def a \a)
(def a2 "Hello")
#+end_src
*** Условные выражения
Рассмотрим выражение,
которое в зависимости от условия выводит что-то в консоль

Выражение состоит из:
 - Условия
 - Тела условия
#+begin_src java
if(true) {
    System.out.println("True");
} else {
    System.out.println("False");
}
#+end_src

Выражение на Clojure почти полностью соответствует
#+begin_src clojure
(if true
  (println "True")
  (println "False"))

;; NOTE: или если мы хотим немного оптимизировать код
(println (if true "True" "False"))
#+end_src
*** Поговорим про синтаксис
В Clojure почти все подчиняется одному синтаксическому правилу
 - Все что исполняется,
   называется ~форма~
   и выглядит как список ~( ... )~
 - То что в ~форме~ на первом месте - ~функция~
 - Остальное ~аргументы~

Безусловно есть исключения, в виде
 - Обычных макросов
 - Структур данных
 - Ридеров
Но в контесте данного воркшопа, они нас не интересуют


* Структуры данных
** Список / List
#+begin_src clojure
(list 1 2 3 4 5 6)
;;Или
'(1 2 3 4 5 6)
;; => (1 2 3 4 5 6)
#+end_src

** Вектор / Vector
#+begin_src clojure
(vector 1 2 3 4 5 6)
;;Или
[1 2 3 4 5 6]
#+end_src

** Строка / String
#+begin_src clojure
(str \H \e \l \l \o 1 2 3)
;;Или
"Hello123"
#+end_src

** Кейворд / Keyword
#+begin_src clojure
(keyword "hello")
;; Или
:hello
#+end_src

** Мапа / HashMap
#+begin_src clojure
(into {} :a 1 :b 2 :c 3)
;; Или
{:a 1
 :b 2
 :c 3}
#+end_src

** Сет / Set
#+begin_src clojure
(set [1 2 3 4 5])
;; Или
#{1 3 2 5 4}
#+end_src



* Козыри пошли
** Деструктуризация
Синтаксическая возможность "раскладывать" элементы массива (и не только)
в отдельные константы или переменные
*** JavaScript
#+begin_src javascript
const [a, b] = [1, 2];
const { a, b } = {"a": 1, "b": 2};
#+end_src
*** Простая деструктуризация
#+begin_src clojure
(let [[a b c] [1 2 3]]
  b)
;; => 2

(let [[a & _] [1 2 3]]
  a)
;; => 1

(let [[_ & bc] [1 2 3]]
  bc)
;; => (2 3)
#+end_src
*** Продвинутая деструктуризация
#+begin_src clojure
(defn destruct
  [[a b c]
   {:keys [k1 k2]}
   {:strs [s1 s2]}]
  [a b c k1 k2 s1 s2])

(destruct [1 2 3] {:k1 4 :k2 5} {"s1" 6 "s2" 7})

#+end_src
** А как же циклы?
*** Пример цикла
который соберет сумму чисел от ~1~ до ~10~
#+begin_src java
int sum = 0;
for (int i = 1; i < 11; i++) {
    sum += i;
}
// sum = 55
#+end_src

Функция ~range~ сгенерирует список чисел от 1 до 11,
которые мы сложим через ~+~
#+begin_src clojure
(apply + (range 1 11))
;; => 55
#+end_src
*** Пример цикла
который соберет первые 5 чисел массива ~array~
#+begin_src java
int[] array = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int[] acc;
int counter = 0;
while (counter < 5) {
    counter += 1;
    acc[counter] = array[counter]
}
// acc = {0, 1, 2, 3, 4}
#+end_src

Функция ~range~ сгенерирует ленивую бесконечную коллекцию,
из которой мы через ~take~ возьмем первые 5 элементов
#+begin_src clojure
(take 5 (range))
;; => (0 1 2 3 4)
#+end_src
** Работа с коллекциями
*** Map
#+begin_src java
List<Integer> integers = List.of(1, 2, 3, 4, 5);
Function<Integer, Integer> doubleFunction = i -> i * 2;

integers.stream()
    .map(doubleFunction)
    .collect(Collectors.toList());
//[2, 4, 6, 8, 10]
#+end_src

#+begin_src clojure
(def integers [1 2 3 4 5])
(defn double-function [i] (* i 2))

(map double-function integers)
;; => (2 4 6 8 10)
#+end_src

Но скорее всего в кложе мы бы сделали вот так
Используя данные
#+begin_src clojure
(map #(* % 2) [1 2 3 4 5])
;; => (2 4 6 8 10)
#+end_src

*** Filter
#+begin_src java
Arrays.asList('x', 'y', '2', '3', 'a').stream()
   .filter(Character::isLetter)
// ['x', 'y', 'a']

Arrays.asList(1, 2, 3, 4).stream()
   .filter(x -> x%2 == 1)
// [1, 3]

Arrays.asList("abc", "", "d").stream()
   .filter(s -> !s.isEmpty())
// ["abc", "d"]
#+end_src

#+begin_src clojure
(filter #(Character/isLetter %) [\x \y \2 \3 \a])
;; => (\x \y \a)

(filter #(= (rem % 2) 1) [1 2 3 4])
;; => (1 3)

(filter not-empty ["abc", "", "d"])
;; => ("abc" "d")
#+end_src

*** Reduce
#+begin_src java
Arrays.asList(1,2,3).stream()
    .reduce(0, (x,y) -> x+y)
// computes (((0+1)+2)+3) to produce the integer 6

Arrays.asList(5, 8, 3, 1).stream()
    .reduce(Math::max)
// computes max(max(max(5,8),3),1) and returns an Optional<Integer> value containing 8
#+end_src

#+begin_src clojure
(reduce + [1 2 3])
;; => 6

(reduce max [5 8 3 1])
;; => 8
#+end_src

** Стрелочки
#+begin_src clojure
;; NOTE: эти формы равны между собой.
;; стрелочный макрос в любом случае превратится, в форму выше

(+ 1 (count (conj 6 (conj 5 [1 2 3 4]))))

(+ 1
   (count
    (conj 6
          (conj 5
                [1 2 3 4]))))

(->> [1 2 3 4]
     (conj 5) ;; => [1 2 3 4 5]
     (conj 6) ;; => [1 2 3 4 5 6]
     (count) ;; => 6
     (+ 1)) ;; => 7
#+end_src


* Repl
Чаще всего этой аббревиатурой характеризуется интерактивная среда языка программирования LISP,
однако такая форма характерна и для интерактивных сред языков
- Erlang
- Groovy
- Haskell
- Java
- JavaScript
- Perl
- PHP
- Python
- Ruby
- Scala
- Smalltalk
- Swift
- Tcl и других

** R ead
Функция ~read~ читает одно выражение и преобразует его в соответствующую структуру данных в памяти
** E val
Функция ~eval~ принимает одну такую структуру данных и вычисляет соответствующее ей выражение
** P rint
Функция ~print~ принимает результат вычисления выражения и печатает его пользователю
** L oop
Бесконечный цикл (~loop~), начинается сначала


* Java
** Interop
#+begin_src clojure
(.toUpperCase "fred")
;; => "FRED"

(.getName String)
;; => "java.lang.String"

(.-x (java.awt.Point. 1 2))
;; => 1

(System/getProperty "java.vm.version")
;; => "1.6.0_07-b06-57"

Math/PI
;; => 3.141592653589793
#+end_src
** Библиотеки
#+begin_src clojure
(ns demo
  (:import (java.util Date Calendar)
           (java.net URI ServerSocket)
           java.sql.DriverManager))
#+end_src
** Исключения
#+begin_src clojure
(try
  (/ 1 0)
  (catch Exception e
    (.getMessage e))
  (finally ()))
#+end_src




* Послесловие по языку
** Функциональный
Поощряется функциональный подход.
Все имеет результат.
Можно управлять функциями как значениями.
Можно композировать функции.

#+begin_src clojure
(fn [])
;; => fn

(defn closure [a]
  (fn []
    (a + 10)))
;; #'user/closure

(closure 5)
;; => (fn [] (5 + 10))

((closure 5))
;; => 15
#+end_src

Почему бы нам не сделать словарь функций
#+begin_src clojure
(def funcs
  {:plus5 (fn [a] (+ a 5))
   :minus10 (fn [b] (- b 10))})

((:plus5 funcs) 10)
;; => 15

((:minus10 funcs) 10)
;; => 0
#+end_src

** Иммутабельный
Мы не мутируем (перезаписываем) значение переменной.
Мы создаем копию или меняем ссылку на объект
#+begin_src java
int i = 5;
i = 6;
// 6
#+end_src

#+begin_src clojure
(def i 5)

(def i* (inc i))

[i i*]
;; => [5 6]
#+end_src
** Структуры персистентные
Структура данных, как гит репозиторий.
Хранит значение при инициализации, и шаги воспроизведения.
Мы редко копируем что-то полностью, чаще мы меняем последние шаги работы со структурой
Поэтому иммутабельность, стоит дешево.
#+begin_src clojure
(def v [1 2])

(def v2 (conj v 3))
;; [1 2] + 3 = [1 2 3]

(def v3 (conj v2 4))
;; [1 2] + 3 + 4 = [1 2 3 4]

(def v4 (conj v2 5))
;; [1 2] + 3 + 5 = [1 2 3 5]

v
;; => [1 2]

v2
;; => [1 2 3]

v3
;; => [1 2 3 4]

v4
;; => [1 2 3 5]
#+end_src
** Data Driven
#+begin_src clojure

;; ---- MAP
(def m {:a 10 :b 20})
;; => #'user/m

(def m+c+d (assoc m :c 30 :d 40))
;; => {:a 10 :b 20 :c 30 :d 40}

(def m+c-d (dissoc m :d))
;; => {:a 10 :b 20 :c 30}

;; ---- VEC

(def v [1 2 3 4])
;; => #'user/v

(def inced (map inc v))
;; => (2 3 4 5)

;; ---- CODE
(-> (list 'def 'k 10) ;; => ('def 'k 10)
    (str) ;; => "(def k 10)"
    (eval)) ;; => #'user/k

#+end_src
