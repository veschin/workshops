#+title: Clojure

* Зачем вам это нужно?
Попробуем ответить на неприятные вопросы:
- Эта технология даст вам карьерное преимущество здесь и сейчас?
  Нет

- Эта технология является популярной? На ней легко найти работу?
  Нет

- Зачем вообще тратить на нее свое время?
  Потому что Clojure способна подарить кардинально новый опыт решения обыденных проблем.
  Не нужно смотреть на этот язык, как на потенциально новый вид деятельности.
  Нужно дать ему шанс, существовать в вашей карьере параллельно с основным источником дохода.
* Введение
** Lisp
Семейство языков программирования,
программы и данные в которых представляются системами линейных списков символов.
#+begin_src lisp
(CAR '(A B C D))
;; => A
#+end_src
** Clojure
Cовременный диалект Лиспа,
язык программирования общего назначения с поддержкой разработки в интерактивном режиме,
поощряющий функциональное программирование и упрощающий поддержку многопоточности.
Clojure работает на платформах JVM и CLR.

** Синтаксис и его отсутствие
*** Функция сложения
Рассмотрим функцию сложения двух чисел.
Например в языке Java есть синтаксические правила, объявления функции.
Объявляем:
 - Тип данных, результата
 - Имя функции
 - Аргументы
 - Тело функции
#+begin_src java
int plus (x, y) {
	return x + y;
}
#+end_src
В Clojure мы делаем почти то же самое, но опускаем тип результата,
потому что язык динамически типизированный.
Через функцию* ~defn~ Объявляем:
 - Имя функции
 - Аргументы
 - Тело функции
#+begin_src clojure
(defn plus [x y] (+ x y))
#+end_src
*** Объявление переменных
Объявляем для переменной:
 - Тип
 - Имя
 - Значение
#+begin_src java
byte b = 216;
short s = 1123;
int i = 64536;
long l = 2147483648L;
float pi = 3.14f;
char a = 'a';
String a2 = "Hello";
#+end_src

Делаем в Clojure то же самое
Через функцию* ~def~
#+begin_src clojure
(def b 216)
(def s 1123)
(def i 64536)
(def l 2147483648L)
(def a \a)
(def a2 "Hello")
#+end_src
*** Условные выражения
Рассмотрим выражение,
которое в зависимости от условия выводит что-то в консоль

Выражение состоит из:
 - Условия
 - Тела условия
#+begin_src java
if(true) {
    System.out.println("True");
} else {
    System.out.println("False");
}
#+end_src

Выражение на Clojure почти полностью соответствует
#+begin_src clojure
(if true
  (println "True")
  (println "False"))

;; NOTE: или если мы хотим немного оптимизировать код
(println (if true "True" "False"))
#+end_src
*** Поговорим про синтаксис
В Clojure почти все подчиняется одному синтаксическому правилу
 - Все что исполняется,
   называется ~форма~
   и выглядит как список ~( ... )~
 - То что в ~форме~ на первом месте - ~функция~
 - Остальное ~аргументы~

Безусловно есть исключения, в виде
 - Обычных макросов
 - Структур данных
 - Ридеров
Но в контесте данного воркшопа, они нас не интересуют


* Структуры данных
** Список / List
#+begin_src clojure
(list 1 2 3 4 5 6)
;;Или
'(1 2 3 4 5 6)
;; => (1 2 3 4 5 6)
#+end_src

** Вектор / Vector
#+begin_src clojure
(vector 1 2 3 4 5 6)
;;Или
[1 2 3 4 5 6]
#+end_src

** Строка / String
#+begin_src clojure
(str \H \e \l \l \o 1 2 3)
;;Или
"Hello123"
#+end_src

** Кейворд / Keyword
#+begin_src clojure
(keyword "hello")
;; Или
:hello
#+end_src

** Мапа / HashMap
#+begin_src clojure
(into {} :a 1 :b 2 :c 3)
;; Или
{:a 1
 :b 2
 :c 3}
#+end_src

** Сет / Set
#+begin_src clojure
(set [1 2 3 4 5])
;; Или
#{1 3 2 5 4}
#+end_src

* Козыри пошли
** Деструктуризация
Синтаксическая возможность "раскладывать" элементы массива (и не только)
в отдельные константы или переменные
*** JavaScript
#+begin_src javascript
const [a, b] = [1, 2];
const { a, b } = {"a": 1, "b": 2};
#+end_src
*** Простая деструктуризация
#+begin_src clojure
(let [[a b c] [1 2 3]]
  b)
;; => 2

(let [[a & _] [1 2 3]]
  a)
;; => 1

(let [[_ & bc] [1 2 3]]
  bc)
;; => (2 3)
#+end_src
*** Продвинутая деструктуризация
#+begin_src clojure
(defn destruct
  [[a b c]
   {:keys [k1 k2]}
   {:strs [s1 s2]}]
  [a b c k1 k2 s1 s2])

(destruct [1 2 3] {:k1 4 :k2 5} {"s1" 6 "s2" 7})

#+end_src
** А как же циклы?
*** Пример цикла
который соберет сумму чисел от ~1~ до ~10~
#+begin_src java
int sum = 0;
for (int i = 1; i < 11; i++) {
    sum += i;
}
// sum = 55
#+end_src

Функция ~range~ сгенерирует список чисел от 1 до 11,
которые мы сложим через ~+~
#+begin_src clojure
(apply + (range 1 11))
;; => 55
#+end_src
*** Пример цикла
который соберет первые 5 чисел массива ~array~
#+begin_src java
int[] array = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int[] acc;
int counter = 0;
while (counter < 5) {
    counter += 1;
    acc[counter] = array[counter]
}
// acc = {0, 1, 2, 3, 4}
#+end_src

Функция ~range~ сгенерирует ленивую бесконечную коллекцию,
из которой мы через ~take~ возьмем первые 5 элементов
#+begin_src clojure
(take 5 (range))
;; => (0 1 2 3 4)
#+end_src
** Работа с коллекциями
*** Map
#+begin_src java
List<Integer> integers = List.of(1, 2, 3, 4, 5);
Function<Integer, Integer> doubleFunction = i -> i * 2;

integers.stream()
    .map(doubleFunction)
    .collect(Collectors.toList());
//[2, 4, 6, 8, 10]
#+end_src

#+begin_src clojure
(def integers [1 2 3 4 5])
(defn double-function [i] (* i 2))

(map double-function integers)
;; => (2 4 6 8 10)
#+end_src

Но скорее всего в кложе мы бы сделали вот так
Используя данные
#+begin_src clojure
(map #(* % 2) [1 2 3 4 5])
;; => (2 4 6 8 10)
#+end_src

*** Filter
#+begin_src java
Arrays.asList('x', 'y', '2', '3', 'a').stream()
   .filter(Character::isLetter)
// ['x', 'y', 'a']

Arrays.asList(1, 2, 3, 4).stream()
   .filter(x -> x%2 == 1)
// [1, 3]

Arrays.asList("abc", "", "d").stream()
   .filter(s -> !s.isEmpty())
// ["abc", "d"]
#+end_src

#+begin_src clojure
(filter #(Character/isLetter %) [\x \y \2 \3 \a])
;; => (\x \y \a)

(filter #(= (rem % 2) 1) [1 2 3 4])
;; => (1 3)

(filter not-empty ["abc", "", "d"])
;; => ("abc" "d")
#+end_src

*** Reduce
#+begin_src java
Arrays.asList(1,2,3).stream()
    .reduce(0, (x,y) -> x+y)
// computes (((0+1)+2)+3) to produce the integer 6

Arrays.asList(5, 8, 3, 1).stream()
    .reduce(Math::max)
// computes max(max(max(5,8),3),1) and returns an Optional<Integer> value containing 8
#+end_src

#+begin_src clojure
(reduce + [1 2 3])
;; => 6

(reduce max [5 8 3 1])
;; => 8
#+end_src

** Стрелочки
#+begin_src clojure
;; NOTE: эти формы равны между собой.
;; стрелочный макрос в любом случае превратится, в форму выше

(+ 1 (count (conj 6 (conj 5 [1 2 3 4]))))

(+ 1
   (count
    (conj 6
          (conj 5
                [1 2 3 4]))))

(->> [1 2 3 4]
     (conj 5) ;; => [1 2 3 4 5]
     (conj 6) ;; => [1 2 3 4 5 6]
     (count) ;; => 6
     (+ 1)) ;; => 7
#+end_src

* Java
** Interop
** Библиотеки
** Исключения
